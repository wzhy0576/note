### 桔子-苹果问题

#### 1. 问题描述

有两类生产者，一类负责生产桔子，一类负责生产苹果；

有两类消费者，一类负责消费桔子， 一类负责消费苹果；

他们共享一个有 20 个存储单元的有界缓冲区，每个存储单元只能放入一种产 品（桔子/苹果）。 

要求：

1. **桔子生产者**专向存储单元里放桔子，**桔子消费者**专等吃存储单元中的桔子；

2. **苹果生产者**专向存储单元里放苹果，**苹果消费者**专等吃存储单元中的苹果；

3. 只有存储单元为空时，桔子生产者或苹果生产者才可向盘子中放入一个水果；

4. 仅当存储单元中有自己需要的水果时，桔子消费者或苹果消费者才可以从盘子中取出。

5. 二类生产者与二类消费者数目均为 20，即 20 个生产者负责生产桔子，20 个生产者负责生产苹 果；

   20 个消费者负责消费桔子，20 个消费者负责消费苹果 。 

   

#### 2.问题分析

首先4个进程对存储单元的操作是互斥的，

而桔子生产者和桔子消费者，苹果生产者和苹果消费者之间又是同步关系，

所以需要设置**2 * 20个同步信号量，20个互斥信号量**



### 3.PV操作

```c
semaphore vacancy[20] = { 1 };    // 互斥信号量，空位上只允许放一个水果
semaphore orange[20]  = { 0 };    // 空位上没有桔子，同步信号量
semaphore apple[20]   = { 0 };    // 空位上没有苹果，同步信号量

process produceAppleTo(int i) {
    while(true) {
        P(vacancy[i]);
        {把苹果放入索引为i的空位};
        V(apple[i]);
    }
}

process produceOrangeTo(int i) {
    while(true) {
        P(vacancy[i]);
        {把桔子放入索引为i的空位};
        V(orange[i]);
    }
}

process consumeAppleFrom(int i) {
    while(true) {
        P(apple[i]);
        {消费掉索引为i的苹果};
        V(vacancy[i]);
    }
}

process consumeOrangeFrom(int i) {
    while(true) {
        P(orange[i]);
        {消费掉索引为i的桔子};
        V(vacancy[i]);
    }
}
```

